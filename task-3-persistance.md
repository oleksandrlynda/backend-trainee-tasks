# **Task-3-Persistance: Реалізувати SQLite-репозиторій для поїздок**

### **Мета**

Перейти від зберігання даних у пам’яті до зберігання у файлі SQLite.
Ти маєш створити нову імплементацію репозиторію, яка працює з SQLite, але не змінює доменну логіку й сервіси.


# **Опис задачі**

У поточному проєкті поїздки зберігаються у пам’яті (in-memory), тому після перезапуску застосунку всі дані зникають.

Твоє завдання:

1. Створити новий клас репозиторію, який працює з SQLite (`sqlite3`).
2. Зберігати та завантажувати поїздки у файл БД.
3. Забезпечити повну сумісність з існуючими доменними сервісами.
4. Підключити SQLite-репозиторій замість in-memory у FastAPI.
5. Створити тестовий playground, який демонструє персистентність.


# **Вимоги до реалізації**

## **1. Створити SQLite-репозиторій**

Файл:
`domain/sqlite_repository.py`

Клас:
`SQLiteTripRepository`

Конструктор приймає шлях до файлу БД, наприклад:
`SQLiteTripRepository("trips.db")`.

Репозиторій має:

* створювати таблицю `trips`, якщо її ще немає
* реалізувати методи:

```
add(trip) -> Trip
get(trip_id) -> Trip | None
list() -> list[Trip]
update(trip) -> Trip
```

Підказки (для trainee):

* Використовуй модуль `sqlite3` зі стандартної бібліотеки.
* Зберігай `departure_time` як текст у форматі ISO (`datetime.isoformat()`).
* Під час читання конвертуй назад у `datetime` (`datetime.fromisoformat()`).
* Використовуй параметризовані SQL-запити (`?`).
* Не забудь `commit()` після insert/update.


## **2. Інтеграція у FastAPI**

У файлі `app/main.py` замінити in-memory репозиторій на:

```
repo = SQLiteTripRepository("trips.db")
```

Інший код FastAPI змінювати не потрібно.


## **3. Playground: демонстрація персистентності**

Створити файл:
`playground_sqlite.py`

У ньому:

* створити репозиторій `SQLiteTripRepository("trips.db")`
* створити кілька поїздок через доменні сервіси
* викликати методи пошуку, статистики, бронювання, скасування
* вивести всі поїздки в консоль
* додати кілька `assert` для перевірки логіки

**Обов’язково:**
Запусти файл двічі — на другому запуску поїздки повинні лишитися у БД.


# **Acceptance Criteria**

[] Таблиця `trips` створюється автоматично
[] Дані записуються у SQLite і зчитуються з нього
[] Сервісні функції (`create_trip`, `search_trips`, …) працюють без змін
[] FastAPI `/trips` повертає дані з SQLite
[] Дані зберігаються після перезапуску застосунку
[] Playground демонструє персистентність
[] Коректна конвертація `datetime` (ISO-format)
[] Код акуратний, зрозумілий, достатньо структурований


# **Що потрібно здати**

* `domain/sqlite_repository.py`
* оновлений `app/main.py` (з новим репозиторієм)
* `playground_sqlite.py`
* короткий вступ у README:
  * як запустити playground
  * як перевірити дані через FastAPI
* Якщо використовуєш AI для допомоги, створи ще один файл: prompts.txt, де записуй промпти і став їм оцінку на скільки вони були помічними для тебе. Приклад в завданні 1.


# **Невеликі навчальні підказки для trainee**

* Репозиторій — це шар доступу до даних. Його можна замінювати без зміни бізнес-логіки.
* SQLite поводиться як “справжня база”, але фізично це один файл — ідеально для тренування.
* Персистентність = дані живуть довше, ніж процес програми.
* Конвертація типів (datetime ↔ string) — важлива частина бекенд-розробки.
* Простий SQL — це must-have навичка для кожного Python backend developer.

Хочеш — сформую **Task-4-Testing** або **Task-4-Repository-Interface** для наступного кроку розвитку trainee?

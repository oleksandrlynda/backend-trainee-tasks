# **Завдання №2 — Domain + Repository + базова інтеграція у FastAPI**

Це завдання продовжує попереднє. Тепер ти працюєш не з вебом, а з **доменом** і **чистою логікою** — це основа бекенд-розробки. FastAPI тут використовується лише як тонкий шар поверх твого коду.


# **1. Створити доменну модель `Trip`**

Створити `dataclass` з полями:

* `id`
* `from_city`
* `to_city`
* `departure_time`
* `seats_total`
* `seats_taken`
* `price`
* `driver_name` (необов’язково)

### Вимоги до значень

* `seats_total > 0`
* `seats_taken <= seats_total`
* `price > 0`

**Хінт:** валідацію можна робити:

* або прямо в `__post_init__()` датакласу;
* або у сервісній функції, яка створює Trip.
  Обери той спосіб, який тобі зрозуміліший.


# **2. Створити клас-сховище `TripRepository`**

Сховище працює **у пам’яті**.

Репозиторій повинен вміти:

* додати поїздку (id має автоінкрементуватися)
* отримати поїздку за id
* повернути список усіх поїздок
* оновити поїздку
  (delete не потрібно)

**Хінт:**
Тут важливо зрозуміти саму ідею Repository:

> Це шар доступу до даних. Інша частина програми не повинна знати *як* саме ми зберігаємо дані.

В наступному Task-3 ти заміниш це сховище на SQLite без змін у домені та бізнес-логіці.


# **3. Реалізувати сервісні функції (бізнес-логіка)**

Функції працюють **через репозиторій**, а не з сирим списком.

Потрібно реалізувати:

### a) Створення поїздки

* перевірити вхідні значення
* встановити `seats_taken = 0`
* передати Trip у репозиторій


### b) Пошук поїздок

Параметри:

* `from_city` (необов’язково)
* `to_city` (необов’язково)

**Хінт:**
Фільтруй результати, які повертає репозиторій.
Простий варіант — спискові включення (list comprehension).


### c) Бронювання місця

* знайти поїздку
* якщо вільних місць нема — кинути помилку
* збільшити `seats_taken`
* оновити поїздку через репозиторій


### d) Скасування бронювання

* знайти поїздку
* якщо `seats_taken == 0` → помилка
* зменшити `seats_taken`
* оновити поїздку


### e) Статистика

* кількість поїздок
* загальна кількість вільних місць

**Хінт:**
Це гарна вправа на обробку списків та роботу із сумами.


# **4. Playground для самотестування**

Створи окремий файл, де:

* створюєш 2–3 поїздки
* викликаєш усі сервісні функції
* додаєш кілька `assert`, що результати правильні
* виводиш щось у консоль для зручності

**Хінт:**
`assert` — це дуже простий спосіб зробити "міні-тести".
Це корисний навик перед тим, як ти перейдеш до справжніх unit tests.

# **5. Мінімальна інтеграція у FastAPI**

У `main.py`:

1. Створити один глобальний об'єкт репозиторію.
2. Додати endpoint:

```
GET /trips
```

Query params:

* `from_city`
* `to_city`

Ендпоінт має:

* отримувати параметри
* викликати сервісну функцію пошуку
* повернути результат у JSON

**Хінт:**
Ти можеш використати:

* або pydantic-модель для відповіді,
* або власноруч конвертувати `dataclass → dict`.

Обери той спосіб, який здається простішим.

# **Що потрібно здати**

1. Код:

   * доменна модель `Trip`
   * клас `TripRepository`
   * сервісні функції (в окремому файлі)
   * playground з assert-тестами
   * оновлений `main.py` з endpoint `/trips`

2. Короткий README:

   * як запустити сервер
   * приклад запиту `/trips?from_city=Kyiv`

3. Файл **prompts.txt**, якщо користувався AI:

   * кожен промпт у новому рядку
   * коротка оцінка (0–10), наскільки він був корисним

Приклад:

```
"Explain how to filter list of objects by field" — 7/10
```

# **Міні-підказки для навичок (insights)**

* Доменна логіка = серце бекенду. Важливо тримати її незалежною від вебу та БД.
* Repository — це спосіб “сховати” деталі зберігання. Завтра це може бути SQLite або PostgreSQL, але домен не зміниться.
* Не бійся кидати `ValueError` у випадку неправильних даних — це нормальна практика.
* Завдання тренує ООП, структурування коду, мислення в термінах бізнес-логіки, не фреймворків.

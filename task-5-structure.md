# **Task-5-Structure: Структура проєкту та відповідальності**

Це завдання не додає нового функціоналу.
Воно вчить **як думати про структуру бекенд-проєкту**.

У реальній розробці більшість проблем виникає не через складну логіку, а через **хаоc в коді**.

## **1. Загальна ідея**

На цьому етапі в проєкті вже є:

* доменна логіка
* репозиторії даних
* FastAPI
* playground
* CLI

Файли з’являлися поступово, і структура почала **розмиватися**.

### Мета таску

> Перебудувати структуру проєкту так, щоб:
>
> * бізнес-логіка була ізольована
> * код можна було розширювати без хаосу
> * нові розробники швидко розуміли, де що знаходиться


## **2. Що потрібно зробити**

### 2.1. Проаналізувати поточну структуру

Перед будь-якими змінами задай собі питання:

* Де зараз знаходиться **бізнес-логіка**?
* Який код працює з **базою даних**?
* Який код відповідає за **ввід/вивід** (API, CLI, playground)?
* Які файли знають *забагато* один про одного?

> **Хінт:**
> Якщо файл імпортує `fastapi`, `argparse` або `sqlite3` — це не домен.


### 2.2. Виділити зони відповідальності

Організуй код у папки так, щоб з назви було зрозуміло:

* за **що** відповідає цей код
* **яку роль** він виконує в системі

Уникай абстрактних назв типу:

* `utils`
* `helpers`
* `misc`

> **Хінт:**
> Потрібно відділити код від конфігурації та інших файлів, для цього він переноситься в папку src/, де в руті репозиторію залишається docker файли, readme та інші.


### 2.3. Розділити “що” і “як”

Переконайся, що:

* бізнес-логіка не знає:

  * яку БД ти використовуєш
  * чи це API, CLI або playground
* репозиторій можна замінити без змін у сервісах
* FastAPI та CLI — лише “обгортки” над логікою

> **Хінт:**
> Якщо два модулі імпортують один одного — структура неправильна.


### 2.4. Виправити імпорти

Після реорганізації:

* виправ усі імпорти
* не використовуй `sys.path`
* не покладайся на “магію” запуску з конкретної директорії

> **Хінт:**
> Якщо ти не можеш пояснити, чому імпорт працює — це проблема.


### 2.5. Один пункт “збирання” системи

У проєкті має бути **одне місце**, де:

* вибирається реалізація репозиторію
* залежності “склеюються” разом

> **Хінт:**
> Бізнес-логіка не повинна створювати репозиторій сама.


## **3. Демонстрація правильності структури**

Після рефакторингу має працювати:

* FastAPI застосунок
* CLI
* playground-скрипти
* SQLite-персистентність

Функціональність не змінюється — **змінюється лише структура**.


## **4. Що потрібно здати**

1. Оновлену структуру проєкту
2. Оновлений `README.md`

   * як запустити API
   * як запустити CLI
   * як запустити playground
3. Оновлений `prompts.txt`, якщо використовував AI:

   * промпт
   * оцінка користі (0–10)


## **Acceptance Criteria**

* Бізнес-логіка ізольована від API та CLI
* Репозиторій можна замінити без змін у сервісах
* Імпорти односторонні та зрозумілі
* Структура читається без пояснень
* Проєкт повністю працює після рефакторингу
* Можеш пояснити **чому** структура саме така

## **Невеликі інсайти**

* Структура — це інвестиція у майбутнє
* Код можна переписати, структуру — набагато важче
* Хороша структура зменшує кількість помилок ще до тестів
